# 排序算法

![排序算法](https://raw.githubusercontent.com/baijiangLai/DataStructureAndAlgorithm/master/images/..%2Fimages%2Fsort%2F%C5%C5%D0%F2%CB%E3%B7%A8.png)

## 1. 冒泡算法

基本思想：

- 给定n个元素，进行n-1趟的比较。
- 第一趟比较能选出最大的元素，第二趟能选出第二大元素，...，第n-1趟数组排序正确。
- 在每趟比较中，进行(n-第几趟-1次)的比较，这样就可以选出每一趟中最大的元素进行沉底。

时间复杂度：
对于n个数，其比较的次数：
(n-1) + (n-2) + ... + 1 = n * (n-1) / 2;
时间复杂度为：
$$
O(n^2)
$$




## 2. 快速排序
基本思想：
- 将数组以某一位数作为基准数进行左右分区。
- 将比这个数大的全部放在右边，比这个数大的全放在左边。
- 对两个区间重复第二步，直到各个区间只有一个数。

具体：
1. 设值两个变量i、j，排序开始的时候: (i = 0, j = N -1)
2. 以数组下表的元素作为基准数，赋值给pivot，即pivot=A[0]=A[i]
3. 由后向前搜索(j--)，找到第一个小于pivot的值A[j]，将A[j]和A[i]的值进行交换
4. 由前向后搜索(i++)，找到第一个大于pivot的值A[i]，将A[i]和A[j]的值进行交换
5. 重复3、4步，直至i==j

时间复杂度：
$$
O(nlog_2n)
$$

## 3. 插入排序
基本思想：
1. 把n个待排序的元素看成一个有序表和一个无序表。
2. 开始的时候有序表只包含1个元素，无序表包含(n-1)个元素。
3. 排序的过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复(n-1)次可完成排序过程。

时间复杂度：
$$O(n^2)$$

## 4. 希尔排序

## 5. 选择排序
基本思想：
1. 首先在未排序序列中找到最小的元素。
2. 将最小的元素放在排序序列的起始位置。
3. 从剩余未排序元素中继续寻找最小的元素，放在已排序序列末尾。
4. 重复上述操作，直到所有的元素均排序完毕。

时间复杂度：
$$O(n^2)$$
## 6. 堆排序

## 7. 归并排序
1. 把给定序列分成长度为n/2的子序列
2. 对这两个子序列分别采用归并排序
3. 将两个排序好的子序列合并程一个最终的排序序列。

## 8. 计数排序
基本思想：
1. 申请一个大小为给定序列中最大数+1的数组。
2. 将每次数出现的次数存放值数组(key:num, value:num出现的次数)中。
3. 依次输出数组中的数。


但是如果是给出排序序列中有一个数远远大于其他数，按照上述思想，那么就会申请一个数组，会造成不必要的浪费

优化：
1. 把数组的大小设值为max - min + 1。
2. 向数组中计数的时候，下标减去一个偏移量min。
3. 最后输出的时候，加上偏移量min。

时间复杂度：
$$O(n+k)$$，n是数组的长度，K是数据的范围

## 9. 桶排序

## 10. 基数排序

## 排序算法分类

- 比较类排序: 通过比较来决定元素之间的相对次序，由于其时间复杂度不能突破O(nlogn).
- 非比较排序: 不通过比较来决定元素之间的相对次序, 它可以突破基于比较排序的时间下界，以线性时间运行。

### 概念

- 稳定: 如果a原本在b前面，排序过后a依旧在b前面
- 不稳定: 如果a原本在b前面，排序过后a可能会在b后面